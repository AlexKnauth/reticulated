## Runtime module used by Transient

from . import base_runtime_exception

class RuntimeCheckError(base_runtime_exception.NormalRuntimeError): 
    def __init__(self, *args):
        super().__init__(*args)
        import sys
        # Deactivate the import hook, so we don't try to typecheck the
        # modules imported by the error handling process
        if hasattr(sys.path_hooks[0], 'retic') and sys.path_hooks[0].enabled:
            sys.path_hooks[0].enabled = False
            sys.path_importer_cache.clear()

def __retic_error(msg):
    # Home of EXTREME EVIL MAGIC

    # The point of this is to make it look like the error is getting
    # raised from the point in the program where the check failed,
    # rather than from this particular module. It's only partially
    # successful: the last line of the stack trace will point to the
    # site of the error, but the lines above that will show the
    # "actual" stack trace. This is because the stack trace is
    # dynamically generated by a raise: we can fuck with the existing
    # traceback from the initial raise below, but when we re-raise it
    # a new, "correct" traceback is generated. I'm not sure how to fix
    # this without taking greater control of the translated program,
    # which I'd like to avoid for both the sake of efficiency (note
    # that the scary shit here only happens after an error is raised
    # and we don't care about efficiency anymore) and readability.

    # If there's a way to insert a hook into Python's exception
    # handling mechanism here, that might be cool...
    try:
        raise RuntimeCheckError(msg)
    except RuntimeCheckError as e:
        from . import retic
        import platform

        if not retic.direct_execution and platform.python_implementation() == 'CPython':
            import ctypes
            tb = e.__traceback__
            
            frame = tb.tb_frame
            cur_filename = frame.f_code.co_filename
            # Grab the frame from before __retic_check was invoked by
            # looking for the first frame where the module isn't this one
            while cur_filename == frame.f_code.co_filename:
                frame = frame.f_back
        
            # Cast the traceback object to a pointer type (!!)
            p4 = ctypes.cast(id(tb), ctypes.POINTER(ctypes.c_uint))
            p8 = ctypes.cast(id(tb), ctypes.POINTER(ctypes.c_ulong))
            # Write the call site's frame info into the traceback (!!!)
            p4[8], p4[9] = frame.f_lasti, frame.f_lineno
            p8[3] = id(frame)
        
        raise

def __retic_check(val, ty):
    if ty is callable:
        if callable(val):
            return val
        else: __retic_error('Value "{}" is not callable'.format(val))
    elif ty is None:
        if val is None:
            return val
        else: raise __retic_error('Value "{}" is not None'.format(val))
    elif ty is float:
        if not isinstance(val, float):
            return __retic_check(val, int)
        else: 
            return val
    elif isinstance(val, ty):
        return val
    else: raise __retic_error('Value "{}" does not have type {}'.format(val, ty.__name__))
